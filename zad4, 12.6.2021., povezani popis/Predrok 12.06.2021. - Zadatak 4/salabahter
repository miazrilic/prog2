//binarno pretrazivanje
int dg=0, gg=n-1, s;
while (dg<=gg) {
    s = (dg+gg)/2;
    if (x == V[s]) 
        break;
    else if (x>V[s]) {
        dg = s+1;
    }
    else if (x<V[s]) {
        gg = s-1;
    }
}
if (dg>gg) 
    printf ("\nBroj nije pronadjen!");
    
//zamjena elemenata
void swap (int *x, int *y) {
    int aux;
    aux = *x;
    *x = *y;
    *y = aux;
}

void selectionSort (int a[], int n) {
    int i, j, min;
    for (i = 0; i < n-1; i++) {
        min = i;
        for (j = i+1; j < n; j++)
            if (a[j] < a[min]) 
                min = j;
        swap(&a[i], &a[min]);
    }
}

void bubbleSort (int a[], int n) {
    int i, j;
    for (i = 0; i < n-1; i++)
	    for (j = 0; j < n-1-i; j++)
		    if (a[j+1] < a[j])
                swap(&a[j], &a[j+1]);
}

//rad s datotekama
//deklaracija funkcije fopen
FILE *fopen(const char *filename, const char *mode)

//deklaracija funkcije fread
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)

//deklaracija funkcije fwrite
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)

//jednostruko povezani popis
typedef struct sllist {
    int number;
    struct sllist *nextNode;
}SLLNODE;

//kreiranje JPP
SLLNODE* createSLList(void) {
    SLLNODE *headNode = (SLLNODE*)calloc(1, sizeof(SLLNODE));
    if (headNode == NULL) {
        perror("Kreiranje");
        return NULL;
    }
    else {
        printf("Unesite cijeli broj!\n");
        scanf("%d", &headNode->number);
        headNode->nextNode = NULL;
    }
    return headNode;
}
//umetanje novog cvora na pocetak JPP
SLLNODE* insertNewNodeSLList(SLLNODE* headNode) {
    SLLNODE *newHeadNode = (SLLNODE*)calloc(1, sizeof(SLLNODE));
    if (newHeadNode == NULL) {
        perror("Kreiranje");
        return headNode;
    }
    else {
        printf("Unesite cijeli broj!\n");
        scanf("%d", &newHeadNode->number);
        newHeadNode->nextNode = headNode;
    }
    return newHeadNode;
}

//obilazak JPP i ispis svih cvorova
int traverseSLList(SLLNODE* traverseNode) {
    int counter = 0;
    if (traverseNode == NULL) {
        return -1;
    }
    else {
        while (traverseNode) {
            counter++;
            printf("Node number: %d\tnumber: %d\tcurrent node addr:\ %p\tnext node addr: %p\n", counter, traverseNode->number, traverseNode, traverseNode->nextNode);
            traverseNode = traverseNode->nextNode;
        }
    }
    return counter;
}

//brisanje jednog cvora JPP
void deleteNodeSLList(SLLNODE** headNode, SLLNODE* targetNode) {
    if (*headNode == targetNode) {
        *headNode = (*headNode)->nextNode;
        free(targetNode);
        printf("Oslobodjen chvor: %p\n", targetNode);
    }
    else {
        SLLNODE* traverseNode = *headNode;
        while (traverseNode->nextNode) {
        if (traverseNode->nextNode == targetNode) {
            traverseNode->nextNode = targetNode->nextNode;
            free(targetNode);
            printf("Oslobodjen chvor: %p\n", targetNode);
            break;
        }
        traverseNode = traverseNode->nextNode;
    }
}
}
//brisanje cijelog JPP
SLLNODE* deleteWholeSLList(SLLNODE* traverseNode) {
    SLLNODE* deleteNode = NULL;
    while (traverseNode) {
        deleteNode = traverseNode;
        traverseNode = traverseNode->nextNode;
        free(deleteNode);
        printf("Oslobodjen chvor: %p\n", deleteNode);
    }
    return NULL;
}
//enumeracija mjeseci u godini
enum months {
    JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC
};

//parametarski makro 
#define kvadrat(x) (x) * (x)
